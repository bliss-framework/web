# Functional vs Procedural vs OOP programming

As you might already know, or as you'll learn over the course of your career, there are three main groups of programming languages. 

- [functional languages](https://en.wikipedia.org/wiki/Functional_programming), represented, for example, by Rust, F#, Swift, Scala, and many others
- [procedural languages](https://en.wikipedia.org/wiki/Procedural_programming), represented, for example, by C, Pascal and others
- [object-oriented languages](https://en.wikipedia.org/wiki/Object-oriented_programming), represented, for example, by C#, Java, and many others

We won't cover every little aspect of these groups, there are better comparisons already out there. We'll just focus on the discussion which one should you use, and ultimately which one is the best.

- [Differences between procedural and OOP programming](https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/)
- [Differences between functional and OOP programming](https://medium.com/@shaistha24/functional-programming-vs-object-oriented-programming-oop-which-is-better-82172e53a526)

## Types of programmers

There are basically three different types of languages explorers, programmers that don't stick to one language their whole life.

### Militant

Militant programmers are those that claims one language, or philosophy (functional, procedural, OOP), is better than the others, and if you are not seeing it that way, use something else and don't bother them.

Militant programmers are convinced everything is possible and best done in the language/philosophy they use, and they are willing to spend hours and hours trying to solve problem at hand with what they use rather than accept there might be a better way to do it.

### Promiscuous

Promiscuous programmers are those that have really no allegiance to any language or philosophy and they simply use what is currently available, or considered best at that time and place. 

We are not really against that, free love and all â˜®, but this leads to very fragmented landscape of your projects. You cannot possible learn all of these languages, so you write, most probably, low quality code in all of them.

### Pragmatic

Pragmatic programmers accept there are better languages for different domains of problems, they accept every philosophy brings different pros and cons. 


## Impure sandwich



## Can we actually teach you something?

